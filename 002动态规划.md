
# 实现动态规划

## 什么是动态规划

动态规划其实是分治法的一种，例如一个大问题可以分解为很多个小问题，如果小问题有重复的，我们就可以复用以前的结果避免重复计算，这样就称为动态规划。

## 什么场景可以用动态规划

动态规划要求问题能分而治之，而且有相同子问题，因此求最大连续子数组和就是其中之一。

这个问题表示给一个数组，如[1, -2, 3, 10, -4, 7, 2, -5]，通过算法得到最大的子数组是[3, 10, -4, 7, 2]，从而得到结果是18。

## 整理算法实现思路

算法思路是这样的，假设我们知道第i-1个结果是什么，那么第i也能推倒出来，无非只有下面两种情况。

```
b[i] = b[i-1] + a[i]，当b[i-1]>0时，这时候的b[i]中包含a[i]。

b[i] = a[i]，当b[i-1]<=0，这时候以a[i]重新作为b[i]的起点。

b[i]不包含a[i]的情况，这种情况在计算b[i]之前已经计算处结果，保存在b[0~i-1]中。最后计算max{b[i]}时会考虑到。
```

因此其实b[i] = max{b[i-1]+a[i]，a[i]}，也就是我们一直记录子数组和最大值，如果来了一个新的数，要么选择加上这个数，要么从这个数从新开始，在这个过程中需要一直记录全局最大值和当前最大值b[i]。

## 通过代码实现算法

首先进入ipython，并构建一个数组。

```
a = [1, -2, 3, 10, -4, 7, 2, -5]
```

然后定义函数，来实现这个算法，初始化最终的结果，还有一个currentSum记录以当前元素结尾的最大值（要么是前面的b[i-1] + a[i]，要么是a[i]）。

```
def max_subarray(a):
  result = a[0]
  currentSum = a[0]

  return result

a = [1, -2, 3, 10, -4, 7, 2, -5]
max_subarray(a)

# Print 1
```

接着我们写for循环，注意第一个变量直接跳过。

```
def max_subarray(a):
  result = a[0]
  currentSum = a[0]

  for i in range(1, len(a)):
    print(i)

  return result

a = [1, -2, 3, 10, -4, 7, 2, -5]
max_subarray(a)

# Print 1
```

记住我们的算法就是当前值如果加上大就用加上的，否则就用新的，然后与全局最终结果比较即可。


```
def max_subarray(a):
  result = a[0]
  currentSum = a[0]

  for i in range(1, len(a)):

    currentSum = max(currentSum + a[i], a[i])
    result = max(result, currentSum)

  return result

a = [1, -2, 3, 10, -4, 7, 2, -5]
max_subarray(a)

# Print 18
```


这是本章内容，希望对你有所帮助。[进入下一章](./003树.md)